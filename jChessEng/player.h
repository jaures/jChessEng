/********************
* Name:			Player Class
* Description:	A Player Class to Handle updating the information
*				about the player's pawns, king, and rooks for determining
*				valid Pawn En Passant, and Castling
*
* Responsibilities:
> Player Name
> Player Color
> Attack Masks Generated By the Engine
> En Passantable Pawns
> Whether Rooks, or King have moved
> Check Status
> Player's Game Score
*
*/

#pragma once
#include "auxStructs.h"

class player
{

#pragma region Private Variables and Functions

private:
	//Function Pointer Type for chssEng::_genAttk() function
	typedef uint64_t(*funct_ptr)(uint_fast8_t);

#pragma	region Private Variables
	//Holds The Player Information
	//8-bit Holding information about player. 
	//	LSB		-> Color, WHITE=0, BLACK=1
	//	1-MSB	-> Game Score (Value of captured Pieces)
	uint_fast8_t plyrInfo;

	//Holds The King Status Information
	//	LSB	-> Check Status, NOT INCHECK = 0, INCHECK = 1
	//	[1]	-> KS-Rook status, NOT MOVED = 0, MOVED = 1 
	//	[2]	-> QS-rook status, NOT MOVED = 0, MOVED = 1
	//	[3]	-> King mv status, NOT MOVED = 0, MOVED = 1
	uint_fast8_t kgInfo;

	//Holds The Pawn En Passant Status Information
	//8-bit Holding info about the En Passant-ability of pawns
	//	LSB	-> Left Most Pawn
	//	MSB	-> Right Most Pawn
	//Set Bit means it can be captured for en passant
	//Note*: And it is from white's perspective, so conversion between white
	//	and black mask is only a **48** bit shift.
	uint_fast8_t pwInfo;

	//Bitboards of all possible attacks by Player's pieces
	//	including friendly and enemy targets
	//	One for each Piece Type
	//	Must be updated with _genAttk
	uint64_t attks[NUM_OF_PTYPES];

	//Pointer to _genAttk() function from chessEng
	//	Used to generate the attack masks for each piece type
	//	of the player & eliminates the need for an actual pointer
	//	to the whole chssEng or gBB to access pieces
	funct_ptr plyr_genAttk;

#pragma endregion


#pragma region Private Functions

	//Default Constructor
	player();


	//Initialization using Standard board
	void init(uint_fast8_t c);

	//Initialization using Custom Board
	void c_init(uint64_t pcsMsk[NUM_OF_PTYPES], uint_fast8_t info[3], bool pedantic = false);

	//Generate and Set attks[] using Custom Board
	void c_setAttks(uint64_t pcs[NUM_OF_PTYPES], uint64_t mv = 0);

	///Updates Player after a move is made
	//
	//Modifies:		>plyrInfo
	//				>kgInfo
	//				>pwInfo
	//
	void update(uint64_t pcs[NUM_OF_PTYPES], uint64_t mv = UINT64_MAX);

	//Updates kgInfo using current pcs[]
	void _update_kgInfo(uint64_t pcs[NUM_OF_PTYPES]);

	//Updates pwInfo using current pcs[]
	void _update_pwInfo(uint64_t pcs[NUM_OF_PTYPES]);

	//Update attks[] using current pcs[] and mv
	void _update_attks(uint64_t pcs[NUM_OF_PTYPES], uint64_t mv);

#pragma endregion


#pragma	region Setter Functions

	//Set the plyrInfo
	void setPlyrInfo(uint_fast8_t info);

	//Set the kgInfo
	void setKgInfo(uint_fast8_t info);

	//Set the pwInfo
	void setPwInfo(uint_fast8_t info);

	//Set Attack Masks
	// > When type is specified, only changes attack mask of that type
	void setAttks(uint64_t* _attks, int num = NUM_OF_PTYPES, pType type = Empty);

#pragma endregion

#pragma endregion

public:

	//Main Constructor
	//	pcsMsk[]	-> Masks of all the Player's Pieces
	//	c		-> Player Color
	//	_genAttk-> funct_ptr to _genAttk
	//	info[3]	-> {plyrInfo, kgInfo, pwInfo}
	//	*Note: When pcsMsk is default, sets attks[] to pre-generated
	//			attack masks for standard board setup
	player(uint_fast8_t c, funct_ptr _genAttk, uint64_t pcsMsk[NUM_OF_PTYPES] = nullptr, uint_fast8_t info[3] = nullptr);

	//Default Deconstructor
	~player();

#pragma region Getter Functions

	//Get the plyrInfo
	uint_fast8_t getPlyrInfo();
	
	//Get Player color
	bool getColor();

	//Get the Player Score
	uint_fast8_t getScore();

	//Get the kgInfo
	uint_fast8_t getKgInfo();

	//Get InCheck Status
	bool getInCheck();

	//Get King Side Castle Status
	bool getKSCstlbl();

	//Get Queen Side Castle Status
	bool getQSCstlbl();

	//Get the pwInfo
	uint_fast8_t getPwInfo();

	//Get A Mask of En Passantable Pawns
	uint64_t getEnPssntbl();

	//Get Attack Mask of type t
	// -if Type is not specified, return full attack Mask
	uint64_t getAttk(pType type = Empty);

	//Get Attack Mask of all Sliding Pieces
	// (Qn, Bp, Rk)
	uint64_t getSlideAttks();

	//Get Attack Mask of all Non-Sliding Pieces
	// (Kg, Kn, Pw)
	uint64_t getNonSlideAttks();

#pragma endregion

};

player::player()
{
}

//Main Constructor
//	pcsMsk	-> Masks of all the Player's Pieces
//	c		-> Player Color
//	_genAttk-> funct_ptr to _genAttk
//	info[3]	-> {plyrInfo, kgInfo, pwInfo}
//	*Note: When pcsMsk is default, sets attks[] to pre-generated
//			attack masks for standard board setup
player::player(uint_fast8_t c, funct_ptr _genAttk, uint64_t pcsMsk[NUM_OF_PTYPES], uint_fast8_t info[3])
{
	if (info == nullptr)
	{
		init(c);
	}
	else
	{
		c_init(pcsMsk, info);
	}

}

player::~player()
{
}

//Initialization using Standard board
void player::init(uint_fast8_t c)
{
	uint64_t colorMsk = (c) ? (INIT_BLACK) : (INIT_WHITE);
	uint64_t initATKS[6] = { INIT_KINGS & colorMsk,
							 INIT_QUEENS & colorMsk,
							 INIT_BISHOPS & colorMsk,
							 INIT_KNIGHTS & colorMsk,
							 INIT_ROOKS & colorMsk,
							 INIT_PAWNS & colorMsk};

	setAttks(initATKS);
}

//Initialization using Custom Board
//
void player::c_init(uint64_t pcsMsk[NUM_OF_PTYPES], uint_fast8_t info[3], bool pedantic)
{
	//Set kgInfo to RNK1 with respect to color
	//	*Okay bad formatting, but it looks kinda 
	//		cool/clever initizialing it like this :P*
	(
		(kgInfo 
			//First set it to RK1 with respect to color
			= (pcsMsk[0] | pcsMsk[4]) >> 56*getColor())	
		
			//Use current value to compute status of kg & rk's statuses
			=(//******Implement getting inCheck Status****/
			(kgInfo & (0x80 >> 7 * getColor())) << 1 |	//Bit for KS Rook Status
			(kgInfo & (0x1 << 7 * getColor())) << 2 |	//Bit for QS Rook Status
			(kgInfo & (0x10 >> getColor())) << 1		//Bit for Kg Status
			)
		);


	//Set pwInfo to RNK1 with respect to color
	pwInfo = pcsMsk[5] >> (24 + 8 * getColor());


	//Switch to throw erros if pedantic
	switch ((kgInfo == info[1]) << 1 | (pwInfo==info[2]))
	{
	case 0b01:
		//Throw Error: Invalid kgInfo
		break;
	case 0b10:
		//Throw Error: Invalid pwInfo
		break;
	case 0b00:
		//Throw Error: Invalid kgInfo and pwInfo
		break;
	default:
		break;
	}
}


///Updates Player after a move is made
//
//Modifies:		>plyrInfo
//				>kgInfo
//				>pwInfo
//
void update(uint64_t pcs[NUM_OF_PTYPES], uint64_t mv)
{

}

//Updates kgInfo using current pcs[]
void player::_update_kgInfo(uint64_t pcs[NUM_OF_PTYPES])
{
	kgInfo = (pcs[King] | pcs[Rook]) >> 56 * getColor();

	kgInfo = 
		//Use current value to compute status of kg & rk's statuses
		(//******Implement getting inCheck Status****/
			(kgInfo & (0x80 >> 7 * getColor())) << 1 |	//Bit for KS Rook Status
			(kgInfo & (0x1 << 7 * getColor())) << 2 |	//Bit for QS Rook Status
			(kgInfo & (0x10 >> getColor())) << 1		//Bit for Kg Status
		);
}

//Updates pwInfo using current pcs[]
void player::_update_pwInfo(uint64_t pcs[NUM_OF_PTYPES])
{
	//Set pwInfo to RNK1 with respect to color
	pwInfo = pcs[Pawn] >> (24 + 8 * getColor());
}

//Update attks[] using current pcs[] and mv
void player::_update_attks(uint64_t pcs[NUM_OF_PTYPES], uint64_t mv)
{
	for (int i = 0; i < NUM_OF_PTYPES; i++)
	{
		//Check to see that this type was affected by the move mv 
		if ((attks[i] | pcs[i]) & mv)
		{
			uint64_t msk = pcs[i];
			attks[i] = 0;

			while (msk)
			{
				attks[i] |= plyr_genAttk(bitpos(msb(msk)));
				msk ^= msb(msk);
			}
		}

	}
}


#pragma	region Setter Functions

//Set the plyrInfo
//
//Modifies:	>plyrInfo
//
void player::setPlyrInfo(uint_fast8_t info)
{
	plyrInfo = info;
}

//Set the kgInfo
//
//Modifies:	>kgInfo
//
void player::setKgInfo(uint_fast8_t info)
{
	kgInfo = info;
}

//Set the pwInfo
//
//Modifies:	>pwInfo
//
void player::setPwInfo(uint_fast8_t info)
{
	pwInfo = info;
}

//Set Attack Masks
// > When type is specified, only changes attack mask of that type
//
//Modifies:	>attks[]
//			
void player::setAttks(uint64_t* _attks, int num, pType type)
{
	if (type == Empty)
	{
		std::copy_n(_attks, NUM_OF_PTYPES, attks);
	}
	else
	{
		attks[type] = *_attks;
	}
}

#pragma endregion


#pragma region Getter Functions

//Get the plyrInfo
uint_fast8_t player::getPlyrInfo()
{
	return plyrInfo;
}

//Get Player color
bool player::getColor()
{
	return plyrInfo % 2;
}

//Get the Player Score
uint_fast8_t player::getScore()
{
	return plyrInfo >> 1;
}

//Get the kgInfo
uint_fast8_t player::getKgInfo()
{
	return kgInfo;
}

//Get InCheck Status
bool player::getInCheck()
{
	return kgInfo % 2;
}

//Get King Side Castle Status
bool player::getKSCstlbl()
{
	return kgInfo & 0xa;
}

//Get Queen Side Castle Status
bool player::getQSCstlbl()
{
	return kgInfo & 0xc;
}

//Get the pwInfo
uint_fast8_t player::getPwInfo()
{
	return pwInfo;
}

//Get A Mask of En Passantable Pawns
uint64_t player::getEnPssntbl()
{
	//Shift the pwInfo to appropriate R5 depending on color
	return uint64_t{ pwInfo } << 8 * (3 + getColor());
}

//Get Attack Mask of type t
// -if Type is not specified, return full attack Mask
uint64_t player::getAttk(pType type)
{
	return (type == Empty) ?
		(attks[King] | attks[Queen] | attks[Bishop] | \
			attks[Knight] | attks[Rook] | attks[Pawn])
		:
		(attks[type]);
}

//Get Attack Mask of all Sliding Pieces
// (Qn, Bp, Rk)
uint64_t player::getSlideAttks()
{
	return attks[Queen] | attks[Bishop] | attks[Rook];
}

//Get Attack Mask of all Non-Sliding Pieces
// (Kg, Kn, Pw)
uint64_t player::getNonSlideAttks()
{
	return attks[King] | attks[Knight] | attks[Pawn];
}

#pragma endregion
